I COMMANDS IN DOCKER 
  -----------------
note that this is note a required section in the exam, but it is important to know as it is a topic that is usually overlooked. 

Refresh the memory about commands in docker : 
let say u want to run a docker container from ubuntu image, the command will be. 
> docker run ubuntu /this will run a docker container and exits immediately.
So why is that ? 
Containers are not designed to run a OS like vms. Containers run on process and exist once it is completed.
So who do u define wich process that will run in the container ? 
When u check a docker file, you will see a instruction
 CMD ["command"] /this define the programm that will run when the container is started 
In our ubuntu cas, the default command is "bash" wich will be waitting for a terminal. since docker does not attach any by default, the container exits. 

To overwrite the default command, you can simply the new process to run to the command like this: 
> Docker run ubuntu sleep 5 /this will run the container and waits for 5 seconds. 
You can make that behevor permment by change the docker file, the default command. 
  CMD command param1
  or 
  CMD ["command","param1"]
exemple : 
 we change change the docker file for ubuntu like this : 
  CMD ["sleep","5"]
So this will always sleep for 5 seconds. 

But what if we wanted the user to be able to set the sleeping time ? something like this ? >docker run ubuntu-sleeper 10 
Well, we will use the instruction ENTRYPOINT ["command"]

The ENTRYPOINT instruction is like CMD instruction as u can specifie the programme that will run by default, but with ENTRYPOINT command, what ever u add to docker run command will be append to the default command. Wich is not the case for the CMD instruction 

so note that if u use 
 CMD the whole command given will be replaced by what u add to the command line
with 
 ENTRYPOINT what u add to the command line will be appended 
        8080/TCP   

II COMMANDS & ARGUMENTS IN K8s
   --------------------------
 Let's say we want to create a pod from the ubuntu-sleeper image that we created above: 

apiVersion : v1
kind : Pod 
metadata: 
  name : ubuntu-slepper
  labels: 
    app : sleeper 
spec : 
  containers : 
    - name : ubuntu-sleeper
      image : ubuntu-sleeper 
This will create a pod that will live for 5 second (the default value) and the dies. 
So how do u specifie a custom time to sleep ? 
for that u add args : ["custom_time"] in the pod's spec 
apiVersion : v1
kind : Pod
metadata:
  name : ubuntu-slepper
  labels:
    app : sleeper
spec :
  containers :
    - name : ubuntu-sleeper
      image : ubuntu-sleeper
      args : ["10"]

So what if you want to overwrite the default command ? the one given in docker file as ENTRYPOINT ? 
for that u add command : ["new command"] in the pod's spec 
apiVersion : v1
kind : Pod
metadata:
  name : ubuntu-slepper
  labels:
    app : sleeper
spec :
  containers :
    - name : ubuntu-sleeper
      image : ubuntu-sleeper
      command : ["sleep2.O"]
      args : ["10"]
so we have : 

    in docker file        vs      in definition file 

ENTRYPOINT          =========>   command 
CMD                 =========>   args 

III A quick note on editing PODs and Deployments
    -------------------------------------------

you CANNOT edit specifications of an existing POD other than the below.

spec.containers[*].image

spec.initContainers[*].image

spec.activeDeadlineSeconds

spec.tolerations

For example you cannot edit the environment variables, service accounts, resource limits (all of which we will discuss later) of a running pod. But if you really want to, you have 2 options:

1. Run the kubectl edit pod <pod name> command.  This will open the pod specification in an editor (vi editor). Then edit the required properties. When you try to save it, you will be denied. This is because you are attempting to edit a field on the pod that is not editable. A copy of the file with your changes is saved in a temporary location.

You can then delete the existing pod by running the command:
> kubectl delete pod webapp
Then create a new pod with your changes using the temporary file
> kubectl create -f /tmp/kubectl-edit-ccvrq.yaml

2. The second option is to extract the pod definition in YAML format to a file using the command
 > kubectl get pod webapp -o yaml > my-new-pod.yaml
Then make the changes to the exported file using an editor (vi editor). Save the changes
 > vi my-new-pod.yaml
Then delete the existing pod
 > kubectl delete pod webapp
Then create a new pod with the edited file
 > kubectl create -f my-new-pod.yaml

Edit Deployments
With Deployments you can easily edit any field/property of the POD template. Since the pod template is a child of the deployment specification,  with every change the deployment will automatically delete and create a new pod with the new changes. So if you are asked to edit a property of a POD part of a deployment you may do that simply by running the command
 > kubectl edit deployment my-deployment

LAB I COMMANDS AND ARGUMENTS  to access the the lab go to https://uklabs.kodekloud.com/topic/commands-and-arguments/

1) How many PODS exist on the system  ? 
 > kubectl get po /there is one pod named ubunutu-sleeper 
2) What is the command used to run the pod ubuntu-sleeper ?
 > kubectl describe po ubuntu-sleeper or kubectl edit po ubuntu-sleeper 
  /and check the command used 
3) Create a pod with the ubuntu image to run a container to sleep for 5000 seconds. Modify the file ubuntu-sleeper-2.yaml 
 > vim ubuntu-sleeper-2.yaml 
 /edit the file to add command and args
 > kubectl create -f ubuntu-sleeper-2.yaml 
4) Create a pod using the file mamed ubuntu-sleeper-3.yaml.  there is something wrong with it. Try to fix it. 
 > vim ubuntu-sleeper-3.yaml 
  correct the error 
 > kubectl create -f ubuntu-sleeper-3.yaml 
5) Update pod ubuntu-sleeper-3 to sleep for 2000 seconds 
 > kubectl edit po ubuntu-sleeper-3 
  /this will create a temporaly file like this /tmp/kubectl-edit-584963160.yaml,  
 > kubectl delete po ubuntu-sleeper-3
  /remember, u can note update the command and args fields in a pod, u have to kill it and recreate it
 > kubectl create -f /tmp/kubectl-edit-584963160.yaml
6) inspect the file Dockerfile given in this dir, what command is run at container startup ? 
  > vim Dockerfile / and check for  what is given as CMD or ENTRYPOINT 
  in our case, it is : python app.py
7) inspect the file Dockerfile2, what command is run at container startup ? 
  > vim Dockerfile2 /and check the default command 
  in this case, the command is : 
  python app.py --color red 

8) inspect the two files under the dir webapp-color-2. what command is run at container startup ? 
 > vim Dockerfile2 /and check 
 in this case, it is : python app.py --color pink

9)Create a pod with the given specifications. By default it displays a blue background. Set the given command line arguments to change it to green
  > vim default-blue-args-green.yaml 
  > kubectl create -f !$

_______END LAB I ______________________

III 1  ENVIRONMENT VARIABLES 
    ---------------------

You can set environmenet variable in a pod by spécifiying the env in the spec section like this : 

apiVersion : v1
kind : Pod
metadata : 
   name : mypod
   labels : 
     tier : web
spec : 
  containers : 
    - name : container_name 
      imange : imange 
      ports : 
        - containerPort : 9999
      env : 
        - name : 
          value : 
note that env is an array, so each element starts with a - 
There multiple ways of setting env value ; 
1 env : 
    - name : APP_COLOR 
      value : pink 
  /plain key value 

2 env : 
    - name : APP_COLOR 
      valueFrom : 
         configMapKeyRef : 
  /From configMaps 

3 env : 
    - name : APP_COLOR 
      valueFrom : 
        SecretKeyRef : 
 /Secrets 

4 envFrom : 
   - configMapRef : 
         name : 


III  2 CONFIGMAPS 
     ------------

ConfigMaps are used to pass configuration data in the form of key value pairs in Kubernetes. 
When a Pod is created, injects the config map into the pod, so the key-value parents are availble as enviroment variables for the application hosted inside the container in the pod. 

As other obejects in k8s, a configMap can be created using imperative command or the declarative way, 
imperative : kubectl create configmap <config_name> --from-literal=<key>=<value>
         or  kubectl create configmap <config_name> --from-file=<path-to-file>

Declarative way using a definition file : 
apiVersion : v1
kind : configMap
metadata : 
  name : config_name 
data : 
   key : value
   key1 : value2
   key3 : value3 
   ...

LAB 2 : CONFIGMAPS to access the lab go to https://uklabs.kodekloud.com/topic/configmaps-2/

1) How many PODs exist on the system in the current(default) namespace ?
 > kubectl get po /there is on pod named webapp-color 
2) What is the environment variable name set on the container in the pod?
 > kubectl describe po webapp-color /check the spec 
3) What is the value set on the environment variable APP_COLOR on the container in the pod? 
 > kubectl describe po webapp-color /check the spec
4) Update the environment variable on the POD to display a green background Note: Delete and recreate the POD. Only make the necessary changes. Do not modify the name of the Pod
 > kubectl edit pod webapp-color /and edit the value of the env, this will generate an error and a tmp file 
  /delete the pod and recreate the pod using the tmp file 
5) How many ConfigMaps exists in the default namespace ? 
 > kubectl get configMaps  / there are two configMaps, one of them is named db-config
6) Identify the database host from the config map db-config 
 > kubectl describe configMap db-config 
7) Create a new ConfigMap for the webapp-color POD. Use the spec given below.
      ConfigName Name: webapp-config-map
      Data: APP_COLOR=darkblue
 > kubectl create configmap webapp-config-map --from-literal=APP_COLOR=darkblue
8) Update the environment variable on the POD to use the newly created ConfigMap
   Note: Delete and recreate the POD. Only make the necessary changes. Do not modify the name of the Pod
 > kubectl edit pod webapp-color /and edit the value of the env, this will generate an error and a tmp file
  /delete the pod and recreate the pod using the tmp file

_____ END LAB 2 ________________


IV  SECRETS 
    --------
Secrets are used to store sensitve information like passwords or keys. there are similar to configMaps except that they are stored in a encoded or hashed format. As with configmaps, there are two steps involed in working with secrets : 
First, create the secret second, injecte it into pod. 
There are two way to create a secrete; imperative way without using a secret definition file and declarative way by using a secret definition file. 

impérative way :  /this way, u can directly specify the key value pairs in the command line itselft. 
 > kubectl crate secret generic <secret_name> --from-literal=<key>=<value>
declarative : 

apiVersion : v1
kind : Secret
metadata : 
  name : <name_of_the_secret>
data : 
  key1 : value1
  key2 : value2
  key3 : value3

However, we seen that secrets are used to store sensitve date and are stored in an encoded format. So value1, value2, value3 ...
must be encoded. But how do u convert the data from plain text to an encoded format ? 
on a linux host, run the command : 
 > echo -n 'value(i)' | base64
to decode, u can use the same command but add --decode after
 > echo -n 'dmFsdWUoaSk=' | base64 --decode 

to use secret in the pod, u put it in the definition file. In the spec section add; 

envFrom : 
   - secretRef : 
         name : <secret_name>

____ LAB 3 SECRETS to access the lab go to : https://uklabs.kodekloud.com/topic/secrets-4/ 

1) How many Secrets exist on the system in the current(default) namespace ? 
 > kubectl get secrets /there is one secret named default-token
2)  How many secrets are defined in the default-token secret ?
 > kubectl describe secrets default-token 
2) What is the type of the default-token secret? 
 > kubectl get secret /and check the Type colmum 
3) What is the type of the default-token secret? 
 > kubectl describe secret default-token 
4) Create a new secret named db-secret with the data given below. You may follow any one of the methods discussed in lecture to create the secret. 
   secret name : db-secret
   secret 1 : DB_Host=sql01
   secret 2 : DB_User=root
   secret 3 : DB_Password=password123
> vim db-secret.yaml 
5) Configure webapp-pod to load environment variables from the newly created secret. Delete and recreate the pod if required.
> kubectl edit po webapp-pod / 
  and in the spec : 
     envFrom : 
       - secretRef :
           name : db-secret

______END LAB 3___________


V SECURITY 
  --------

V.1 Security in Docker 
  --------------------
Let us start with a host with Docker installed on it. the host have it's own processes. Let now run an ubuntu container that runs a process that sleeps for an hour. Remember, container are not completely isolated from thier hosts, they share the same kernel. 
So containers are isoleted using Namespaces in Linux. When a container is run, it can only see processes in it's own namespace. However, the process of the container are visible in the host but, ofcause, with a different process IDs. That is about processes. 

Let's see about users. 
The host has a set of Users, a root user as well as number of non-root users. By Default, Docker runs processes within containers as the root user. But u can change that default behavours and set a user u want by specifying the user id. In docker u can use this command : 
> docker run --user=1000 ubuntu sleep 3600
You can also do that in the Dockerfile using the USER instrucation > docker run --user=1000 ubuntu sleep 3600 

One question : if u run a container with a root user, is it the same root user in the container as the host ? wich will make the root user in the container to do anything on the host system ? 
> Well, Docker implements a set of security features that limits the abilities of the root user within a container. so the do not have quite same capabilities. By default, some capabilities are not given to the root user in the container. However, u can add some capabilities by add the --cap-add <capability> in the docker run command: 
> docker run --cap-add MAC_ADMIN ubuntu. 
 /you can also drop some capabilities by using --cap-drop flag
 /you can also give all the capabilities to the user by adding the flag --privileged. 

you can check all capabilities avaible in linux system at this link : /usr/include/linux/capability.h  



