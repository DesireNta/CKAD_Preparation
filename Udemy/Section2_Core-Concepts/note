* Kubernetes Architecture 

Nodes aka Minions 

A node is a machine, virtual or phyisic 
A cluster is a set of nodes grouped together. 

A cluset has a master node that mananges other nodes, it is called the master while other are workers

Kubernets componentes => when u install k8s, u actualy install the folwing components 

  - API server
  - Scheduler
  - Controller 
  - Container runtime  
  - kubelet 
  _ etcd 

API Server acts as the k8s front end; each command will hit directly the api server. 
etcd is a ditributed reliable key-value store used buy K8s to store all the information 
Scheduler is responsible for distributing loads across all the nodes 
Controller are the brain of the k8s
Container runtime is the underling software that is used to run container, it can be Docker, rkt or cri-o
Kubelet is an agent that runs on each node in the cluster. 

The master have a kube-apiserver, that is what makes it a master 


I  POD
   ____

A pod is the smollest object that u can create in k8s
a pod contains generaly one application. 
there are some use cases where we can run two applications in the same pode but they have to have the same lifetime 

: To create a pod with had hoc commande 
 => kubeclt run nginx --image <image_name>


Creating pod using yaml: 

apiVersion: v1 #this is determines the family of the object u want to create  
Kind: Pod # defines the type of the object
metadata:
  name : myapp-pod 
  labels: 
    app: myapp
    type : front-end

spec:
  containers : # list/array
    - name : ndinx-container
      image : nginx


Once the file is created, run the commande "kubeclt craete -f <name_of_the_file>"

Once the pod is created, u can run the command kubectl get pods to see ur pod running 
You can also us the command "kubectl describe pod <pod_name>"



LAB 1 about PODS : to access labs go to this link : https://uklabs.kodekloud.com/courses/labs-certified-kubernetes-application-developer 
____

1) How many pods exist on the system ? 
 > kubeclt get po   /this will get u all the nodes deployed in defaul namespace
2) Create a pod with the nginx image 
 > kubectl run nginx --image nginx 
3) how many pods are created now ? /they had added new po in the labs 
 > kubectl get po 
4) What is the image used to create new pods ? 
 > kubectl describe pod <name of one of the pods>
5) Which nodes are these pods placed on ? 
 > kubectl get po -o wide /this lists pods and more info which contains node
6) how many containers are part of the pod webapp ? 
 > kubectl get po /and then check the colmon READY to see number of expected pods
7) what images are used in the new webapp pod 
 > kubectl describe pod webapp /go check the images in spec section 
8) what is the state of the container agentx in the pod webapp ? 
 > kubectl describe po webapp /check state
9) why do you think the container agentx in pod webapp is in error ? 
 >/A Docker image with this name doent not exist on Docker hub
10) what does the READY column in the output of the kubectl get pods command indicates ? 
 > Running containers in pod/Total containers expected in Pod
11) Delete the webapp Pod 
 > kubectl delete po webapp
12) Create a new pod with the name redis and with the image redis123 (Use a pod-definition YAML file, and yes the image is wrong)
 > vim redis.yaml
 > kubectl create -f redis.yaml
 /this will create a pod but it's STATUS will be ImangePullBackOff
13) Now change the image on this pod to redis
 > kubectl edit po redis
 /this will open a the recap file in vi/vim wich have all the information about the po, once u edit the image and save, it will update the pod. note that this does not change the orginal file 

Note that there are 3 way to edit pod : 
  1 by editing the the definition file when it exists
  2 by extractind the definition file using this commande 
    >kubectl get pod <pod name> - yaml > pod-definition.yaml
  3 use the kubectl edit pod <pod-name> 

------------  END LAB PODS --------------------


II  KUBERNETES CONTROLLERS 
    ___________________

Controller are the brain behind kubernetes processes that monitors k8s objects and repond accordingly

II.1 Replication controller

what is the replication controller and why do we need it ? 
In the first part we created bare pod that was running one application, what happens if for some reason the pod dies ? well the application will no longer be accessible for the users 

The replication controller helps us run multiple instances of the application so multiple pod, but it can alse be used to run just one pod. If one pod dies, the controller will create a new to keep the desired number of the pods (application instances)

Another advantage of using replication controller, is Load Balancing & Scaling 

One thing to know there are two simular terms : 

Replication controller   |  Replica Set 
both have the same purpers but the are not the same 

Replication controller is the older version that is being replaced by Replica Set, it is now recommend to use replica set 

A replication controller definition file looks like this

apiVersion : v1 
kind : ReplicatoinController
metadata :
   labels: 
     app : myapp
     type : front-end
spec: 
  template : 
    /here u put every thing need to create a pod, except the apiVersion and the kind. So u will have something like 
    metadata:
       name: 
       labels: 
    spec: 
  replicas : 3 

After the file is created run > kubectl create -f <file name>
To see the created replication controllers created (in this case one) run 
> kubectl get replicationcontroller

a replica set definition file looks like this : 

apiVersion : apps/v1 (notice the difference) 
kind : ReplicaSet
metadata:
  labels: 
spec: 
  template : 
    /here u put every thing need to create a pod, except the apiVersion and the kind. So u will have something like
    metadata:
       name:
       labels:
    spec:
  replicas: number
  selector:
    matchLabels:
 
  /this is required while creatting a ReplicaSet, this help the RS to know wich pod is under it. This means that the replicaset can controlle pods that are created out of it self. Once a pod muches the selector, it is part of the replicat set. 
/Note that selector is available in replication controller but it is not required. 

after the file is created, run > kubectl create -f <file name> 
to seet the created replicaset run 
> kubeclt get replicaset 

Scale with replicaset : There are multiple ways to do that 
  1 Edit the number of need replicas in the definition file, and the run this command 
   > kubectl replace -f <file name>
  2 run the scale command in adhoc 
   > kubectl scale --replicas=<new number of replicas> -f <file name>
   You can also use this command like this 
   > kubectl scale --replicas=<new number of replicas> replicaset <replicaset name>
   
   However, this will not update the number of replicas in the definition file
  3 you can also scale based on the application load but that is an advenced topic, we will see that later 


LAB 2 REPLICASETS to access the lab go to : https://uklabs.kodekloud.com/topic/replicasets-2/

1) How many Pods exists on the system ? 
 > kubectl get po /this will show pods deployed in the default namespace 
2) How many ReplicaSets exists on the system 
 > kubectl get rs /this will show replicasets that are deployed in default namespace
3) How about now (We just made a few changes)
 > kubectl get rs 
4) How many PODs are DESIRED in the new-replica-set ? 
 > kubectl get rs /check the DESIRED colmun 
5) What is the image used to create the pods in the new-replica-set ? 
 > kubectl describe rs new-replica-set /this will display all the info about the replicaset where u can see the image
6) How many PODs are READY in the new-replica-set ?
 > kubectl get rs /check the READY colmun
7) Why do you think the PODs are not ready ? 
 / The image used does not exist on docker hub registry 
8) Delete any one ot the 4 PODs 
 > kubectl delete pod 
9) How many PODs exist now ? 
 > kubectl get po /we can see that the rs has recreated the pod 
10) Why are there still 4 PODs, even after you deleted one ? 
 /the ReplicaSet ensures that desired number of PODs alwas run 
11) Create a ReplicaSet using the replicaset-definion-1.yaml (there is an issue with the file, os try to fix it)
 > vim replicaset-definition-1.yaml 
 /edit the apiVersion wich is incorrect 
 > kubectl create -f replicatset-definition-1.yaml 
12) Fix the issue in the replicaset-definition-2.yaml file and create replicaset using it 
 > vim replicaset-definition-2.yaml 
  /there was a miss macth between the labels 
 > kubectl create -f replicatset-defiinition-2.yaml
13) Delete the two newly created ReplicaSets
 > kubectl delete rs replicaset-1
 > kubectl delete rs replicaset-2
14) fix the original replica set new-replica-set to use the correct busybox image 
 > kubectl edit rs new-replica-set 
 /and the delete all the pods to restard new ones 
15) Scalle the ReplicaSet to 5 PODs 
 > kubectl scale --replicas=5 rs new-replica-set 
16) new scale the ReplicaSet down to 2 pods 
 > kubectl scal -replicas=2 rs new-replica-set. 

_________ END LAB 2 REPLICASETS _______________ 


III DEPLOYMENT 
    ----------
The deploymetn provides us with the capability to upgrade the underlying instances seamlessly using rolling updates, undo changes and pause and resume changes required. So the deployments over wrappes the replicat set adding the possibility to controlle the updates and upgrades of the application. 

To create the deployment it is exactly the same definition file as the replicat set, Only the kind changes to Deployment 

LAB 3 DEPLOYMENT to access the lab go to : https://uklabs.kodekloud.com/topic/deployments-5/

from 1 to 9, same questions as above

10) Create a new Deployment using the deployment-definition-1.yaml (there is an issue with the file, so try to fix ti)
 > vim deployment-definition-1.yaml 
  /there is an error on the kind, this is case sensitive 
  /after fixing, run 
 > kubectl create -f deployment-definition-1.yaml 
11) Create a new Deployment with the below attributes using your own deployment definition file with this information : 
    Name: httpd-frontend 
    Replicas: 3
    image : httpd: 2.4-alpine
  > vim  my-deploy-def-file.yaml  
  after editing the file run command 
  >kubectl create -f my-deploy-def-file.yaml 

______ END LAB 3 DEPLOYMENT ________________

CERTIFICATION TIP : Formatting output with kubectl 

The default output format for all <kubectl> commands is human readable plain-tex format. 

The -o flag allows us to outpout the details in several different formats. 

> kubectl [command] [TYPE] [NAME] -o <output_format>
Here is some of the commonly used formats: 

1) -o json : Output a JSON formatted API object. 
2) -o name : Print ony the resource name and nothing else.
3) -o wide : Output int the plain-text format with any additional information
4) -o yaml : Output a YAML formatted API object 

 for more details, refer :  
https://kubernetes.io/docs/reference/kubectl/overview/
https://kubernetes.io/docs/reference/kubectl/cheatsheet/ 

